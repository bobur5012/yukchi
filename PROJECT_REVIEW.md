# Изучение проекта Yukchi (frontend)

## 1) Что это за проект

Это фронтенд‑приложение на **Next.js 16 + React 19 + TypeScript**, ориентированное на мобильный формат использования (учёт поездок, товаров, курьеров, долгов магазинов). Приложение использует App Router, клиентские состояния через Zustand и REST API через `NEXT_PUBLIC_API_URL`.

## 2) Технологический стек

- **Framework/UI:** Next.js (App Router), React, Tailwind CSS, shadcn/ui, Framer Motion, Lucide.
- **State:** Zustand (+ persist middleware).
- **i18n:** локали `ru`/`uz` в JSON + хук `useTranslations`.
- **PWA:** `@ducanh2912/next-pwa`, `manifest.json`, service worker в `public/`.
- **Интеграция с API:** общий клиент `apiFetch` с Bearer-токеном и обработкой 401.

## 3) Структура и слои

- `src/app` — маршруты и layout’ы (auth/main/offline/API proxy).
- `src/components` — UI-компоненты и feature-компоненты:
  - `dashboard`, `trips`, `shops`, `couriers`, `products`, `profile`, `settings`.
- `src/lib/api` — слой HTTP-запросов по доменам (`dashboard`, `trips`, `shops`, ...).
- `src/stores` — Zustand-хранилища (`auth`, `trips`, `shops`, `currency`, ...).
- `src/types` — общие типы доменов.
- `src/locales` — словари переводов.

## 4) Ключевые архитектурные наблюдения

1. **Глобальный route guarding на клиенте**
   - `RouteGuard` перенаправляет неавторизованных на `/login`.
   - Есть role-based ограничение для курьеров (`/shops`, `/couriers` недоступны).

2. **Auth-модель**
   - Токен хранится в `localStorage` (`yukchi_token`).
   - Параллельно хранится persist-состояние `yukchi_auth` для пользователя/флага авторизации.
   - При 401 токен и persist-ключ удаляются, пользователь отправляется на `/login`.

3. **API-слой унифицирован**
   - Общий `apiFetch` автоматически добавляет `Authorization`.
   - Поддерживает стандартные методы `get/post/put/patch/delete`.
   - Поддерживает оба формата ответа: `{"data": ...}` и «плоский» JSON.

4. **UX-фокус на мобильный сценарий**
   - В `main` layout есть мобильный контейнер, фиксированный нижний nav, плавные анимации.
   - Доминирует подход client components для интерактивности и реактивных переходов.

5. **i18n без внешней библиотеки**
   - Простой словарный доступ по ключам (`dashboard.totalDebt` и т.п.).
   - Подход лёгкий, но без pluralization/formatting-движка.

## 5) Важные несоответствия/риски

1. **README выглядит как для монорепозитория**, но текущий каталог содержит только фронтенд-часть.
2. **Часть хранилищ выглядит «legacy/локальной»** (например, `trips` store хранит данные в памяти), при том что основные экраны уже работают через API.
3. **Guard реализован только на клиенте** — для полноценной безопасности важна серверная проверка ролей на API (что обычно и делается).
4. **Сильная зависимость от localStorage-токена** — нужно внимательно отслеживать сценарии истечения/обновления токена.

## 6) Как запускать и проверять локально

```bash
npm install
npm run dev
```

Обязательно задать `NEXT_PUBLIC_API_URL` (через `.env`) на backend, иначе запросы пойдут на дефолтный локальный URL.

## 7) Рекомендации по следующим шагам

1. Актуализировать `README.md` под фактическую структуру этого репозитория.
2. Зафиксировать архитектурное решение: какие Zustand stores остаются клиентскими, какие полностью API-driven.
3. Добавить минимальные smoke-тесты (например, проверка редиректов auth/role).
4. Определить стратегию refresh-token (если backend поддерживает), чтобы снизить количество forced logout.
5. Добавить короткий ADR по i18n (оставаться на JSON-хуке или перейти на next-intl).
